# array
## array
- 宣告方法
    - 只要在宣告變數後面加上 [ ]，這樣就會變成array的宣告方法了。
    - .[ ] 裡面放的數字代表這個陣列的大小。舉個例子來說，int a[100]，這個意思就是說我宣告了100個 int 大小的變數，

:::danger
注意：array是從 0 開始，所以 int a[100] 的第一個變數是 a[0]， 最後一個是 a[99]， 並沒有 a[100]， 所以在使用array的時候要注意有沒有超過的問題。
:::

```c
#include <stdio.h>
int main()
{
    int a[100];
    double b[100];
    
    return 0;
}
```

## 注意事項
- array 可以宣告在 function 裡面， 也可以宣告在 global， 差別在於，宣告在 function 裡面的大小有限（約 10^5 ），不能太大， 而宣告在 global 裡， 則可以大到 2^32。

## 設定初值
- 一般來說，array 在宣告完之後，基本上不會自動歸零。

- 舉個例子來說，如果我今天宣告一個 int a[3] ，且沒有給初始值了話。那電腦可能會存成 a[0] = 451, a[1] = 4445, a[2] = 98432。（依電腦不一樣也有差別，以xcode來說，他會自動將它歸零，但大部分的電腦不會，所以傳上去OJ會錯）

- 歸零的方法大致分為 4 種

### 第一種：對於宣告在 global 的 array 來說，由於宣告在 global 所以 compile 時，系統會將整個 array 歸零，所以如果沒有特別需求了話，並不用將他定值。
```c
#include <stdio.h>
int a[3];
int main()
{
    int i;
    for(i = 0; i<3; i++)
    {
        printf("%d : %d\n", i, a[i]);
    }
    return 0;
}

```
結果會得：

0 : 0

1 : 0

2 : 0

### 第二種：用{}
```c
#include <stdio.h>
int main()
{
    int a[5] = {4,6};
    int i;
    for(i = 0; i<5; i++)
    {
        printf("%d : %d\n", i, a[i]);
    }
    return 0;
}

```
結果：

0 : 4

1 : 6

2 : 0

3 : 0

4 : 0

由結果可知，如果我們只對陣列的部份元素設定初值，則其餘的元素會被自動設為 0。


### 第三種：只宣告第一個變數
```c
#include <stdio.h>
int main()
{
    int a[5] = {2};
    int i;
    for(i = 0; i<5; i++)
    {
        printf("%d : %d\n", i, a[i]);
    }
    return 0;
}

```
結果：

0 : 2

1 : 0

2 : 0

3 : 0

4 : 0

由結果可得，如果我們今天想把一個非glogal array歸零了話，只要將第一個變數設為零，這樣整個array就會全部都是0了。

### 第四種：不設定大小
```c
#include <stdio.h>
int main()
{
    int a[] = {2,6,7,4,3};
    int i;
    for(i = 0; i<5; i++)
    {
        printf("%d : %d\n", i, a[i]);
    }
    return 0;
}

```
結果：

0 : 2

1 : 6

2 : 7

3 : 4

4 : 3


   - 假如我們在設定初值時，設定的數值超過當初宣告的大小，舉例來說：int a[3] = {1,2,3,4}; ，陣列大小是 3，但是設了四個值，這樣的寫法是不被允許的，在 compile 時就會出錯。
   - 此時改成 int a[] = {1,2,3,4}; 則不會有問題。
  - 使用這種寫法，我們就不必自己指定陣列大小，而讓 compiler 依照我們給的初值個數決定陣列要多大。


## 違規
- 如果再寫程式時，發現讀寫 array 時，會 runtime error，可以檢查看看是否自己的 array 是否有讀取到錯誤的地方


- 由於c compiler 並不會幫我們判斷我們的array是否有宣告錯誤。所以在宣告和運算時必須要很注意。


- 舉個例子來說：
```c
#include <stdio.h>
int main()
{
    int a[] = {2,6,7,4,3};
    printf("%d\n", a[-1]);
    return 0;
}
```
此時complier不會跑出任何警告訊息，而會直接讓你compile 成功，但結果卻無法控制，不同的compiler也可能會有不同的結果。

不檢查的原因要回溯到 C 語言的設計理念：基本上 C 語言相信程式設計者知道自己在做什麼，因此對於程式設計者完全信賴，給予很大的自由，而這樣可以換來執行速度變快的優勢。由於陣列的索引是否超出範圍並不是在 compile 時就能完全偵測出來，大多數情況下必須到了 runtime，也就是程式執行時才能發現索引超出範圍；為了要在執行時能夠檢查出陣列索引超出範圍，compiler 必須在程式裡額外加入一些負責檢查範圍的程式碼，但這樣一來就會讓程式的執行速度變得比較慢。因此，C 語言寧願相信程式設計者永遠都是在做正確的事情，藉此換得執行速度較快的程式。話雖如此，但不見得每個程式設計者都那麼值得信賴。如果程式設計者自己亂搞而搞砸了，後果就要自行負責。

## 二維陣列
- 宣告方法：
    int a[3][5] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14};
- 你可以把它想成：
    int a[3][5] = {  {0,1,2,3,4}, {5,6,7,8,9,10} ,{ 11,12,13,14} };
    


| Column 0 | Column 1 | Column 2 |Column 3  | Column 4 
| -------- | -------- | -------- | -------- | -------- 
| a[0][0]  | a[0][1]  | a[0][2]  | a[0][3]  | a[0][4] 
| a[1][0]  | a[1][1]  | a[1][2]  | a[1][3]  | a[1][4] 
| a[2][0]  | a[2][1]  | a[2][2]  | a[2][3]  | a[2][4] 

:::danger
注意元素的編號
:::

雖然我們把資料排列方式想像成二維，但是實際上電腦是用循序的方式來儲存資料，所以其實就只是一維，也就是說每個二維陣列裡的資料是一列接著一列放置在記憶體裡。使用二維陣列表示法只是為了方便我們在寫程式時可以用比較直觀的方式思考。

再來看看這個例子：

```c
#include <stdio.h>
int main()
{
    int a[10];
    int b[10][10];
    
    printf("size of 1d array : %lu bytes\n", sizeof( a[0]) );
    printf("size of 2d array : %lu bytes\n", sizeof( b[0]) );
    
    return 0;
}

```

結果：

size of 1d array : 4 bytes

size of 2d array : 40 bytes

＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿

講解：在一維陣列裡，一個變數大小是 4 bytes，也就是一個 int 的大小，而在二維陣列裡， b[0] 裡面則有 10 個 int 的大小， 你也可以想成，在 b[0] 裡面存了 10 個 int 變數。
