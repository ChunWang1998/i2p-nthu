# 第三章：讀取和輸出各種型別的資料 #
## 輸入數值 ##
```C
範例 1

#include <stdio.h>
int main(void) /* calculate earned run average */
{
   float er, ip, era;

   printf("How many earned runs did you give up?\n");
   scanf("%f", &er);
   printf("How many innings did you pitch?\n");
   scanf("%f", &ip);

   era = 9.0 * er / ip;  
   printf("ERA = %.2f\n", era);
  
   return 0;
}
```
這個簡單的程式會讓使用者輸入自責分和投球局數，然後算出防禦率並顯示在螢幕上。在解釋程式的細節之前，先來看看這個程式裡有哪些新東西。首先是變數宣告的地方，出現了 float 這個沒看過的型別 (之前是用 `int`)。再來是除了 `printf()` 之外還出現了 `scanf()` 這個新的 function。另外 `printf()` 的字串參數裡還出現 `%.2f` 的格式。

我們就來一一解釋這些新東西。首先是 `float` 型別，為了計算的精確度，可以把變數宣告成 `float` (浮點數)。在這個例子中，由於我們要計算的數值包含小數點後的位數，所以不適合再用 `int` 整數型別來儲存數值，而要用能夠表示更精細的數值的浮點數型別變數。整數和浮點數儲存數值的方式不一樣，我們會再做更詳細的介紹，目前暫時先記得，處理整數的資料，就用 `int` 變數；處理有小數點的資料，就用 `float`。

程式接下來用 `printf()` 顯示訊息，指示使用者輸入自責分是多少，然後用 `scanf()` 來讀取使用者鍵盤輸入的數值。我們先前看過的例子都沒讓使用者自己輸入變數的值，變數值都在程式碼裡面設定，所以每次更改數值，都要重新 compile 程式再執行，才能得到新的結果，這是很不方便的操作方式。所以我們要讓程式能在執行中讀取使用者想要設定的變數值，多了這樣的互動功能，才比較符合一般的使用需求。我們已經學過，要讓 C 程式輸出資訊可以用 `printf()`，而要讓 C 程式讀取輸入的資料則可以用 `scanf()`，它的使用方法和 `printf()` 類似，都要先用第一個參數指定格式，然後剩下的參數就是對應的變數。不一樣的地方是變數名稱前面多了& 符號。所以這一行程式碼 

```C
scanf("%f", &er); 
```
就會把使用者輸入的數值存入變數 `er` 中。讀取的格式為 `float`，因此用 `%f` 告訴 `scanf()` 要讀取的資料的格式是浮點數。至於為什麼 `scanf()` 傳參數的時候要多一個 `&`？ 底下用一個簡單的比喻來解釋：
如果把變數想成一個盒子，則變數名稱 (譬如 `er`) 就是寫在盒子上的標籤，用來和其他盒子區別，而盒子裡的東西就是那個變數所儲存的數值。當我們要將變數當作參數傳給某個 `function` (譬如 `printf()`) 的時候，C 語言的作法就是把盒子裡的東西拿出來交給那個 `function`。但是對於像是 `scanf()` 這樣功能的 `function` 來說，它要的並不是盒子裡的東西，而是要整個盒子，因為它要把使用者輸入的數值放進盒子裡。要達到把整個盒子當參數 (而不是把盒子裡的東西當參數) 的這個目的，作法就是在參數變數前加上 `&`，告訴 compiler 要把整個盒子傳給 `scanf()`。初學者最常犯的錯誤就是在使用 `scanf()` 讀取整數或浮點數變數的時候，忘了在變數前面加上 &。
接下來的數值運算 `era = 9.0 * er / ip`; 就是依照我們要的計算公式把答案算出來存放在變數 `era` 裡。其中 `*` 代表乘法運算，而 `/` 代表除法運算。最後再把結果用 `printf()` 顯示在螢幕上。

## 整數 int 型別和浮點數 float 型別 ##

C 語言裡面當你的數值有小數點的時候，就不適合再用整數來儲存，而要用浮點數。當你寫 3 的時候，這個數會被當成是整數，當你寫 3.0 就變會被認為是浮點數。除了直接寫出整個數值，浮點數還可以用以十為底的科學記號的方式來表示，譬如：2.5e-4 就相當於 2.5 乘上 10 的 -4 次方，也就是 0.00025。浮點數和整數在電腦裡的儲存格式不一樣，整數會完全用二進位編碼來儲存整個數值，浮點數則會拆成幾個部份，包括正負號、底數、指數三個組成元素。用這樣的方式來儲存，讓我們可以用浮點數來表達更大範圍的數值(譬如 -2 後面接 50 個零，這麼大的數只要寫成 -2e50，所以只要記錄 i) 是個負數，ii) 底數是 2，iii) 指數是 50 就夠了)。然而浮點數的精確度仍舊是有限的，所以有時候浮點運算結果可能和你預期的結果之間會有點誤差，譬如你覺得算出來的答案應該是 1.0，但是實際上儲存的浮點數可能是 0.999999。以後我們會再用一些例子實際說明使用浮點數必須特別注意哪些情況。
## 整數型別 int ##
大多數的電腦用的是 32-bit 整數，但是隨著轉換到 64 位元處理器，整數長度也會跟著更改成 64-bit。位元長度決定整數可以表示的數值的大小範圍。如果是用長度 32-bit 的空間來儲存一個整數，那麼可以表達的整數值範圍就是 -231 ~ 231-1 (包含了負數和 0) 。宣告整數變數的方法我們已經看過，就是 int 後面接變數名稱：
```C
int birds;
int cats, dogs;
```
宣告變數之後變數還要設定變數值，可以直接在程式碼中設定，譬如  cats = 3; 或是使用 scanf() 或其他 function 來取得並設定變數的值。還有一種方式是在宣告的時候就順便把值設定好，也就是所謂的初始化 (initialization)：
```C
int birds = 10; 
int cats = 3, dogs = 2;
```
注意，第二行如果寫成 int cats, dogs = 2; 則只有 dogs 會做初始化。
整個宣告加初始化做的就是右圖所表示的動作。

在 C 程式裡面，5, 8, -32 這樣的直接寫出來的整數稱作常數 (不需用要變數來儲存的數值)。前面提過，如果寫成 5.0 就會被當成浮點數常數。

我們已經學過如何用 printf() 來顯示 int 變數：printf() 的第一個參數可以搭配 "%d" 來指定輸出格式為十進位整數。要注意的是格式的部份要由程式設計者負責，如果對應錯誤，出來的結果就會是錯的。譬如下面的例子：
```C
範例 2 

#include <stdio.h>
int main(void)
{
   int five = 5; 
   int one = 1;
   
   printf("%d minus %d is %d\n", five, one, five - one);
   printf("%d minus %d is %d\n", five); /* 少了兩個參數 */

   return 0;
}
```
程式輸出的結果可能是
```
10 minus 2 is 8
10 minus 2 is 8
```
少了兩個參數竟然還會跑出結果! 這只是湊巧，因為當 %d 找不到對應的參數時，`printf()` 取得的就是當時記憶體中剛好在本來預期的位置裡存放的數值，至於裡面會有什麼值，就要看你的運氣，在這個例子缺少的兩個參數所對應到的記憶體位置，裡面湊巧存放的是 `2` 和 `8`。類似的情況會讓你以為程式沒有錯誤，要特別小心這種 bugs。

除了可以用 `%d` 十進位表示法來顯示整數，`printf()` 還可以用 `%x` 十六進位表示法來顯示整數，譬如 `0x1f` 表示十進位的 `31 (=1*16+15)`，這樣的表示法常用在 binary 資料。
```C
範例 3

#include <stdio.h>
int main(void)
{
   int x = 100; 
   
   printf("decimal: %d, hexadecimal: %x\n", x, x);
   printf("decimal: %d, hexadecimal: %#x\n", x, x);

   return 0;
}
```
```
輸出
  decimal: 100, hexadecimal: 64
  decimal: 100, hexadecimal: 0x64
```
第二個 printf() 用 "%#x" 只是會在顯示的數值前面多加 0x。

## 其他整數型別 ##
除了 int 之外，C 程式裡面還可以把變數宣告成其他種類的整數，包括不同長度的型別： short, long, long long。關於
short, long, long long 的位元數的定義，大家可以到課程網頁的參考資料連結，去查一查 The GNU C Programming
Tutorial (ctut.pdf) Chapter 5, pp. 19-20。另外我們還可以在整數型別前面加上 unsigned，用來表示這個整數變數不包
含負數的部份：
```C
unsigned int x = 20;
```
如果你很確定變數 x 的值不會是負的，就可以把它宣告成 unsigned，這樣原本用來表達負數所需的空間就可以拿來表達
更大的正數。譬如同樣使用 32 bits，原本 int 如果範圍是 -2,147,483,648 ~ 2,147,483,647，宣告成
```
unsigned int 範圍就變成 0 ~ 4,294,967,295。
```
```C
範例 4
#include <stdio.h>

int main(void)
{
unsigned int un = 3000000001;
short small = 300;
long big = 65537;
printf("un = %u and not %d\n", un, un);
printf("small = %hd and %d\n", small, small);
printf("big = %ld and not %hd\n", big, big);
return 0;
}
```



得到的輸出結果如下。用 `printf()` 輸出時要配合型別設定顯示格式，才能得到正確的輸出結果。
```
un = 3000000001 and not -1294967296
small = 300 and 300
big = 65537 and not 1
```
接下來我們要看一種情況：當我們想要儲存的數值超過了整數型別可以表達的範圍時，會發生所謂的 Integer Overflow 的
問題，譬如下面的例子。
```C
範例 5
#include <stdio.h>

int main(void)
{
int i = 2147483647;
unsigned int j = 4294967295U;
printf("%d %d %d\n", i, i+1, i+2);
printf("%u %u %u\n", j, j+1, j+2);

return 0;
}
```
大家可以想想看如何解釋這樣的現象。
```
輸出：
 2147483647 -2147483648 -2147483647
 4294967295 0 1
```

## 使用字元 char 型別 ##
```C
範例 6
#include <stdio.h>

int main(void)
{
char ch;

printf("Please enter a character: ");
scanf("%c", &ch);
printf("ASCII code for '%c' is %d.\n", ch, ch);
return 0;
}
```
前面的範例用到了幾個新的東西。首先是 `char` 型別，它會用到 `8-bit` 的記憶體空間，靠 `8 bits` 所儲存的數值來表達字元，譬如 'A', 'e', '7' 等等單一的英文字母或數字。要將數值對應到字元，我們需要特定的編碼方式，通常會有一個編碼的對照表來對應數值和字元。最常用的是 `ASCII code` 編碼，可以把 0 到 127 的數值對應到不同的字元。前面的範例就是要使用者輸入一個字元，然後程式會把對應的 `ASCII` 編碼秀出來。範例裡的 `scanf()` 和 `printf()` 還用到了 `%c`。對於`scanf()` 來說，使用 `%c` 的格式，表示輸入的資料會被當成字元，譬如輸入的是 7，就會把 7 當成字元而不是整數 7。同樣地，`printf()` 裡用 `%c` 的格式，也是要把傳入的參數的數值所對應的字元顯示出來。我們用下面的範例和練習來看看 `%c` 和 `%d` 的差別。
```C
範例 7
#include <stdio.h>

int main(void)
{
printf("character: %c ASCII code: %d\n", 55, '7');
return 0;
}
```
在數字或字母兩邊加上單引號 ' '，就表示要把它當成字元。(另外還有一種八進位表示法，譬如十進位的 55 寫成八進位就是 067，也可以寫成 '\067' 來表示 '7'。)
我們平常使用的中文編碼是 BIG5，中文字數目比較多，所以需要兩個 bytes 才足夠編碼常用的中文字，譬如
```
printf("%c%c\n", 0xa7, 0x70);
```
在支援中文的 DOS console 下會顯示出一個中文字。(有時候網頁或郵件出現亂碼就是因為編碼錯誤或是用錯了對照表。)
## 使用浮點數型別 float, double ##
```C
範例 8
#include <stdio.h>

int main(void)
{
float x = 12345.0;
double y = 2.34e12;
printf("%f or %e\n", x, x);
printf("%f or %e\n", y, y);
return 0;
}
```
可以用 %f 格式或是 %e 科學記號格式來表示浮點數。浮點數運算也有 overflow 的問題，譬如
```C
float s = 3.4e38 * 10.0;
printf("%e\n", s);
```
由於 `3.4e38` 已經接近 `float` 可容許的範圍的邊緣，再乘上 `10.0` 之後就爆掉，所以會得到輸出結果是`1.#INF00e+000`，表示無限大。使用浮點數另外有一個要注意的是 `round-off error` 的問題，譬如
```C
float a, b;
b = 1.0e12 + 1.0;
a = b - 1.0;
printf("%f\n", a);
```
照理答案應該是 1 後面接 12 個 0，但是實際上會得到奇怪的數字。這是因為要對兩個大小差很多的數目做運算時，只用float 並不足夠同時精確表達兩個數目。

## 使用 sizeof 查詢型別的佔用的 byte 數 ##
```C
範例 9
#include <stdio.h>

int main(void)
{
printf("int: %u bytes, char: %u bytes,\n", sizeof(int), sizeof(char));
printf("long: %u bytes, double: %u bytes.\n", sizeof(long), sizeof(double));
return 0;
}
```
這個範例使用 `sizeof` 這個內建 `operator` 來顯示 `int`, `char`, `long`, `double` 這些型別所佔用的 byte 數目。

當我們把數值設定給變數時，要注意變數的型別是否符合我們的需求，譬如
```C
int a = 9.99;
float pi = 3.1415926536;
```

這兩個情況都無法把我們想要的數值存到變數裡。對變數 a 來說，小數點後面的數目會被無條件捨去，所以 a 的值會是9。至於 float 的精確度只有保證六個有效位數，因此超過的位數就不一定正確。如果用 double 的話可以保證到十個有效位數。

## Flushing the Buffer ##
當你使用 `printf()` 把資料顯示到螢幕上時，其實並不會立即顯示在螢幕上，而是先送到所謂的 buffer 裡。要等到下列幾種情況才會做 flushing the buffer 的動作，把 buffer 裡的資料沖到螢幕上：i) 當 buffer 滿的時候；ii) 當 '\n' 字元出現的時候；iii) 當接下來是做輸入的動作的時候 (譬如遇到 scanf())。

有時候為了讓資料能立刻顯示到螢幕上，可以用 fflush() 強迫把 buffer 裡的東西送出。當你發現有時候輸入或輸出的顯示順序會亂掉，可以試著在 printf() 之後用 `fflush()` 來確保資料不會被卡在 buffer 裡。


